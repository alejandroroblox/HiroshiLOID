<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HiroshiLOID</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f3f4f6; /* Fondo gris claro */
        }
        .tab-button.active {
            background-color: white;
            color: #ec4899; /* pink-600 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .tab-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .tab-button.active:hover {
            background-color: white;
        }
        /* Estilos para el scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #d1d5db; /* gray-300 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #9ca3af; /* gray-400 */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex flex-col items-center justify-center z-50 hidden">
        <img src="https://raw.githubusercontent.com/google-gemini/gemini-canvas-samples/main/images/Gemini_Generated_Image_dovm1hdovm1hdovm.jpg" onerror="this.src='https://raw.githubusercontent.com/google-gemini/gemini-canvas-samples/main/images/Gemini_Generated_Image_dovm1hdovm1hdovm.jpg'" alt="Cargando..." class="w-48 h-48 animate-pulse rounded-full shadow-lg">
        <p class="mt-4 text-white text-xl font-semibold">Cargando...</p>
    </div>

    <div id="custom-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center z-50 hidden p-4">
        <div class="bg-white rounded-lg shadow-xl p-6 max-w-sm w-full border-2 border-pink-300">
            <h3 id="modal-title" class="text-xl font-bold mb-4 text-pink-600"></h3>
            <div id="modal-message" class="text-gray-700 mb-6"></div>
            <div class="flex justify-end space-x-3">
                <button id="modal-close-button" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg hover:bg-gray-300 transition duration-200">
                    Cerrar
                </button>
                <button id="modal-confirm-button" class="px-4 py-2 bg-pink-500 text-white rounded-lg hover:bg-pink-600 transition duration-200 hidden">
                    Confirmar
                </button>
            </div>
        </div>
    </div>

    <header class="bg-gradient-to-r from-pink-500 to-purple-600 p-4 shadow-lg">
        <nav class="container mx-auto flex flex-col sm:flex-row justify-between items-center space-y-4 sm:space-y-0">
            <h1 class="text-white text-2xl font-bold">HiroshiLOID</h1>
            <div class="flex space-x-2 sm:space-x-4">
                <button id="tab-synthesis" class="tab-button px-4 py-2 rounded-lg font-semibold transition duration-300 active">
                    S√≠ntesis de Voz
                </button>
                <button id="tab-creator" class="tab-button px-4 py-2 rounded-lg font-semibold transition duration-300">
                    Crear Voicebank HLVB
                </button>
            </div>
            <div id="user-id-display" class="text-white text-sm text-center sm:text-right">
                </div>
        </nav>
    </header>

    <main class="flex-1 container mx-auto p-4 sm:p-6">
        <div id="synthesis-tab-content" class="tab-content">
            <h2 class="text-3xl font-extrabold text-center text-pink-700 mb-8">S√≠ntesis de Voz</h2>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">Archivos HL y Acciones</h3>
                    <div class="space-y-3">
                        <button id="load-hl-button" class="w-full px-5 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition duration-200 shadow-md">
                            Cargar Archivo HL
                        </button>
                        <button id="save-hl-button" class="w-full px-5 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition duration-200 shadow-md">
                            Guardar Archivo HL
                        </button>
                        <button id="add-note-button" class="w-full px-5 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition duration-200 shadow-md">
                            A√±adir Nueva Nota
                        </button>
                        <button id="edit-note-button" class="w-full px-5 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition duration-200 shadow-md" disabled>
                            Editar Nota Seleccionada
                        </button>
                        <button id="delete-note-button" class="w-full px-5 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition duration-200 shadow-md" disabled>
                            Eliminar Nota Seleccionada
                        </button>
                        <button id="play-synthesis-button" class="w-full px-5 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 transition duration-200 shadow-md">
                            Reproducir Audio
                        </button>
                        <button id="save-synthesis-button" class="w-full px-5 py-2 bg-pink-500 text-white rounded-lg hover:bg-pink-600 transition duration-200 shadow-md">
                            Sintetizar y Guardar Audio
                        </button>
                    </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">Selecci√≥n de Voicebank</h3>
                    <select id="voicebank-combo" class="w-full p-2 border border-gray-300 rounded-md focus:ring-pink-300 focus:border-pink-300">
                        <option value="">Seleccionar Voicebank...</option>
                        </select>
                    <div id="selected-voicebank-info" class="mt-4 text-sm text-gray-600">
                        </div>
                </div>

                <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">Idioma de S√≠ntesis</h3>
                    <select id="language-combo" class="w-full p-2 border border-gray-300 rounded-md focus:ring-pink-300 focus:border-pink-300">
                        </select>
                    <p class="mt-4 text-sm text-gray-600">
                        <span class="font-bold">Nota:</span> La s√≠ntesis de voz del navegador no usa el voicebank.
                    </p>
                </div>
            </div>

            <div class="flex flex-col lg:flex-row gap-6 mb-8">
                <div class="flex-1 bg-white p-4 rounded-lg shadow-md border border-gray-200 overflow-x-auto">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">Notas del Piano Roll</h3>
                    <table id="piano-roll-table" class="min-w-full bg-white border border-gray-300 rounded-lg">
                        <thead class="bg-gray-100">
                            <tr>
                                <th class="py-2 px-4 border-b text-left text-gray-600">Tono</th>
                                <th class="py-2 px-4 border-b text-left text-gray-600">Inicio</th>
                                <th class="py-2 px-4 border-b text-left text-gray-600">Duraci√≥n</th>
                                <th class="py-2 px-4 border-b text-left text-gray-600">Letra</th>
                            </tr>
                        </thead>
                        <tbody>
                            </tbody>
                    </table>
                </div>

                <div class="flex-1 bg-white p-4 rounded-lg shadow-md border border-gray-200">
                    <h3 class="text-xl font-semibold mb-4 text-gray-800">Fonemas del Voicebank</h3>
                    <div class="overflow-y-auto h-96">
                        <table id="phoneme-table" class="min-w-full bg-white border border-gray-300 rounded-lg">
                            <thead class="bg-gray-100 sticky top-0">
                                <tr>
                                    <th class="py-2 px-4 border-b text-left text-gray-600">Alias</th>
                                    <th class="py-2 px-4 border-b text-left text-gray-600">Archivo Wave</th>
                                </tr>
                            </thead>
                            <tbody>
                                </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200 mb-8">
                <h3 class="text-xl font-semibold mb-4 text-gray-800">Vocaloid Changer (Simulado)</h3>
                <p class="text-sm text-gray-600 mb-4">
                    Introduce texto para transformarlo a un estilo "Vocaloid" (solo textual). La reproducci√≥n de audio usar√° la voz est√°ndar de tu navegador, no un voicebank personalizado. Para un Vocaloid real, se necesita un backend de IA.
                </p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label for="input-vocaloid-text" class="block text-sm font-medium text-gray-700">Texto de Entrada:</label>
                        <textarea id="input-vocaloid-text" rows="4" placeholder="Escribe tu texto aqu√≠ para vocaloid-ificar..." class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity-50"></textarea>
                        <button id="vocaloid-ify-button" class="mt-3 w-full px-5 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition duration-200 shadow-md">
                            Vocaloid-ificar Texto
                        </button>
                    </div>
                    <div>
                        <label for="output-vocaloid-text" class="block text-sm font-medium text-gray-700">Texto Vocaloid-ificado:</label>
                        <textarea id="output-vocaloid-text" rows="4" readonly class="mt-1 block w-full rounded-md border-gray-300 bg-gray-50 shadow-sm"></textarea>
                        <button id="play-vocaloid-text-button" class="mt-3 w-full px-5 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition duration-200 shadow-md">
                            Reproducir Texto Vocaloid
                        </button>
                    </div>
                </div>
            </div>

            <div id="synthesis-status" class="bg-white p-4 rounded-lg shadow-md border border-gray-200 text-center text-gray-700 font-medium">
                Estado: Listo.
            </div>
        </div>

        <div id="creator-tab-content" class="tab-content hidden">
            <h2 class="text-3xl font-extrabold text-center text-pink-700 mb-8">üéÄ HLVB Voicebank Creator üéÄ</h2>

            <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200 mb-6">
                <h3 class="text-xl font-semibold mb-4 text-gray-800">Configuraci√≥n del Voicebank</h3>
                <div class="space-y-4">
                    <div>
                        <label for="vb-name" class="block text-sm font-medium text-gray-700">Nombre:</label>
                        <input type="text" id="vb-name" placeholder="Nombre del Voicebank" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50" />
                    </div>
                    <div>
                        <label for="vb-author" class="block text-sm font-medium text-gray-700">Autor:</label>
                        <input type="text" id="vb-author" placeholder="Autor del Voicebank" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50" />
                    </div>
                    <div>
                        <label for="vb-desc" class="block text-sm font-medium text-gray-700">Descripci√≥n:</label>
                        <textarea id="vb-desc" placeholder="Descripci√≥n del Voicebank" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50"></textarea>
                    </div>
                    <div>
                        <label for="vb-epochs" class="block text-sm font-medium text-gray-700">√âpocas de Entrenamiento (Simulado para Python/Torch):</label>
                        <input type="number" id="vb-epochs" value="15" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50" />
                    </div>
                </div>
            </div>

            <div class="bg-white p-6 rounded-lg shadow-md border border-gray-200 mb-6">
                <h3 class="text-xl font-semibold mb-4 text-gray-800">Cargar Archivo oto.ini</h3>
                <input type="file" id="oto-ini-upload" accept=".ini" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-pink-50 file:text-pink-700 hover:file:bg-pink-100" />
                <div id="oto-ini-preview" class="mt-4 p-3 bg-gray-100 rounded-md text-sm text-gray-700 overflow-auto max-h-40 hidden">
                    <h4 class="font-semibold mb-2">Contenido de oto.ini (primeras l√≠neas):</h4>
                    <pre id="oto-ini-content-display" class="whitespace-pre-wrap"></pre>
                </div>
            </div>

            <div class="flex-1 bg-white p-4 rounded-lg shadow-md border border-gray-200">
                <h3 class="text-xl font-semibold mb-4 text-gray-800">Fonemas Cargados (oto.ini)</h3>
                <div class="overflow-y-auto h-96">
                    <table id="creator-phoneme-table" class="min-w-full bg-white border border-gray-300 rounded-lg">
                        <thead class="bg-gray-100 sticky top-0">
                            <tr>
                                <th class="py-2 px-4 border-b text-left text-gray-600">Alias</th>
                                <th class="py-2 px-4 border-b text-left text-gray-600">Archivo Wave</th>
                            </tr>
                        </thead>
                        <tbody>
                            </tbody>
                    </table>
                </div>
            </div>

            <button id="train-pack-button" class="mt-6 w-full px-6 py-3 bg-gradient-to-r from-pink-500 to-red-500 text-white rounded-lg text-lg font-bold hover:from-pink-600 hover:to-red-600 transition duration-300 shadow-lg transform hover:scale-105">
                Entrenar y Crear HLVB (‚úø‚ó†‚Äø‚ó†)
            </button>

            <div id="creator-status" class="bg-white p-4 rounded-lg shadow-md border border-gray-200 text-center text-gray-700 font-medium mt-6">
                Estado: ¬°Bienvenida! Completa los datos. (‚óï‚Äø‚óï‚úø)
            </div>

            <p class="mt-4 text-sm text-gray-600 italic text-center">
                Consejo: El entrenamiento es simulado. Una GPU (CUDA) acelerar√≠a mucho el proceso en una aplicaci√≥n real con Python y Torch.
            </p>
        </div>
    </main>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, collection, query, onSnapshot, addDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables (provided by the environment)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db;
        let auth;
        let currentUserId = null;
        let isAuthReady = false;

        // --- Utility Functions ---
        function showLoading() {
            document.getElementById('loading-overlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        function showModal(title, message, showConfirmButton = false, onConfirmCallback = null) {
            document.getElementById('modal-title').innerHTML = title;
            document.getElementById('modal-message').innerHTML = message;
            const confirmBtn = document.getElementById('modal-confirm-button');
            confirmBtn.onclick = () => {
                if (onConfirmCallback) onConfirmCallback();
                hideModal();
            };
            if (showConfirmButton) {
                confirmBtn.classList.remove('hidden');
            } else {
                confirmBtn.classList.add('hidden');
            }
            document.getElementById('custom-modal').classList.remove('hidden');
        }

        function hideModal() {
            document.getElementById('custom-modal').classList.add('hidden');
        }

        document.getElementById('modal-close-button').addEventListener('click', hideModal);

        // --- Data Classes (JavaScript equivalents of Python classes) ---
        class PianoNote {
            constructor(pitch, start, length, lyric) {
                this.pitch = pitch;
                this.start = start;
                this.length = length;
                this.lyric = lyric;
            }

            toFirestore() {
                return {
                    pitch: this.pitch,
                    start: this.start,
                    length: this.length,
                    lyric: this.lyric,
                };
            }

            static fromFirestore(data) {
                return new PianoNote(data.pitch, data.start, data.length, data.lyric);
            }
        }

        class PhonemeEntry {
            constructor(wave_file_path, alias, offset, consonant, cutoff, pre_utterance, overlap) {
                this.wave_file_path = wave_file_path;
                this.alias = alias;
                this.offset = offset;
                this.consonant = consonant;
                this.cutoff = cutoff;
                this.pre_utterance = pre_utterance;
                this.overlap = overlap;
            }

            toFirestore() {
                return {
                    wave_file_path: this.wave_file_path,
                    alias: this.alias,
                    offset: this.offset,
                    consonant: this.consonant,
                    cutoff: this.cutoff,
                    pre_utterance: this.pre_utterance,
                    overlap: this.overlap,
                };
            }

            static fromFirestore(data) {
                return new PhonemeEntry(
                    data.wave_file_path,
                    data.alias,
                    data.offset,
                    data.consonant,
                    data.cutoff,
                    data.pre_utterance,
                    data.overlap
                );
            }
        }

        class Voicebank {
            constructor(id, name, author, description, otoIniContent = '', infoJsonContent = '') {
                this.id = id;
                this.name = name;
                this.author = author;
                this.description = description;
                this.otoIniContent = otoIniContent; // Raw string content of oto.ini
                this.infoJsonContent = infoJsonContent; // Raw string content of info.json
                this.phoneme_map = {}; // Parsed map of phonemes
                if (otoIniContent) {
                    this.parseOtoIni(otoIniContent);
                }
            }

            parseOtoIni(otoIniString) {
                this.phoneme_map = {};
                const lines = otoIniString.split('\n');
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine && !trimmedLine.startsWith('#')) {
                        try {
                            const eqPos = trimmedLine.indexOf('=');
                            if (eqPos === -1) throw new Error("Missing '='");
                            const wav = trimmedLine.substring(0, eqPos);
                            const rest = trimmedLine.substring(eqPos + 1);
                            const fields = rest.split(',');
                            if (fields.length === 6) {
                                const entry = new PhonemeEntry(
                                    wav, fields[0], parseFloat(fields[1]), parseFloat(fields[2]),
                                    parseFloat(fields[3]), parseFloat(fields[4]), parseFloat(fields[5])
                                );
                                this.phoneme_map[entry.alias] = entry;
                            } else {
                                throw new Error(`Incorrect number of fields (expected 6, got ${fields.length})`);
                            }
                        } catch (e) {
                            console.warn("Error parsing oto.ini line:", trimmedLine, e);
                        }
                    }
                });
            }

            toFirestore() {
                return {
                    name: this.name,
                    author: this.author,
                    description: this.description,
                    otoIniContent: this.otoIniContent,
                    infoJsonContent: this.infoJsonContent,
                    hlvb_version: "1.0",
                };
            }

            static fromFirestore(id, data) {
                return new Voicebank(
                    id,
                    data.name,
                    data.author,
                    data.description,
                    data.otoIniContent,
                    data.infoJsonContent
                );
            }
        }

        // --- Global State Variables ---
        let currentNotes = [];
        let availableVoicebanks = [];
        let selectedVoicebank = null;
        let selectedNoteIndex = null; // For Piano Roll table selection

        const languageOptions = {
            "Espa√±ol": "es", "Ingl√©s": "en", "Franc√©s": "fr", "Alem√°n": "de",
            "Japon√©s": "ja", "Coreano": "ko", "Chino (Mandar√≠n)": "zh-cn",
            "Ruso": "ru", "Italiano": "it", "Portugu√©s": "pt"
        };

        // --- DOM Elements ---
        const synthesisTabBtn = document.getElementById('tab-synthesis');
        const creatorTabBtn = document.getElementById('tab-creator');
        const synthesisTabContent = document.getElementById('synthesis-tab-content');
        const creatorTabContent = document.getElementById('creator-tab-content');

        const loadHlButton = document.getElementById('load-hl-button');
        const saveHlButton = document.getElementById('save-hl-button');
        const addNoteButton = document.getElementById('add-note-button');
        const editNoteButton = document.getElementById('edit-note-button');
        const deleteNoteButton = document.getElementById('delete-note-button');
        const playSynthesisButton = document.getElementById('play-synthesis-button');
        const saveSynthesisButton = document.getElementById('save-synthesis-button');
        const voicebankCombo = document.getElementById('voicebank-combo');
        const languageCombo = document.getElementById('language-combo');
        const pianoRollTableBody = document.querySelector('#piano-roll-table tbody');
        const phonemeTableBody = document.querySelector('#phoneme-table tbody');
        const synthesisStatusLabel = document.getElementById('synthesis-status');
        const userIdDisplay = document.getElementById('user-id-display');
        const selectedVoicebankInfo = document.getElementById('selected-voicebank-info');

        // Vocaloid Changer Elements
        const inputVocaloidText = document.getElementById('input-vocaloid-text');
        const vocaloidifyButton = document.getElementById('vocaloid-ify-button');
        const outputVocaloidText = document.getElementById('output-vocaloid-text');
        const playVocaloidTextButton = document.getElementById('play-vocaloid-text-button');


        // Creator Tab Elements
        const vbNameInput = document.getElementById('vb-name');
        const vbAuthorInput = document.getElementById('vb-author');
        const vbDescInput = document.getElementById('vb-desc');
        const vbEpochsInput = document.getElementById('vb-epochs');
        const otoIniUploadInput = document.getElementById('oto-ini-upload');
        const otoIniPreviewDiv = document.getElementById('oto-ini-preview');
        const otoIniContentDisplay = document.getElementById('oto-ini-content-display');
        const creatorPhonemeTableBody = document.querySelector('#creator-phoneme-table tbody');
        const trainPackButton = document.getElementById('train-pack-button');
        const creatorStatusLabel = document.getElementById('creator-status');

        let currentOtoIniContent = ''; // For creator tab

        // --- Functions to Update UI ---
        function updatePianoRollTable() {
            pianoRollTableBody.innerHTML = ''; // Clear existing rows
            if (currentNotes.length === 0) {
                pianoRollTableBody.innerHTML = `<tr><td colspan="4" class="py-4 text-center text-gray-500">No hay notas. ¬°A√±ade una!</td></tr>`;
                return;
            }
            currentNotes.forEach((note, index) => {
                const row = pianoRollTableBody.insertRow();
                row.classList.add('hover:bg-blue-50', 'transition', 'duration-150');
                if (selectedNoteIndex === index) {
                    row.classList.add('bg-blue-100');
                }
                row.onclick = () => selectNoteInPianoRoll(index);

                row.insertCell().textContent = note.pitch;
                row.insertCell().textContent = note.start;
                row.insertCell().textContent = note.length;
                row.insertCell().textContent = note.lyric;
            });
            updateSynthesisButtonsState();
        }

        function selectNoteInPianoRoll(index) {
            selectedNoteIndex = index;
            updatePianoRollTable(); // Re-render to apply selection styling
            updateSynthesisButtonsState(); // Enable/disable edit/delete buttons
        }

        function updatePhonemeTable(phonemeMap, targetTableBody) {
            targetTableBody.innerHTML = ''; // Clear existing rows
            const phonemes = Object.values(phonemeMap);
            if (phonemes.length === 0) {
                targetTableBody.innerHTML = `<tr><td colspan="2" class="py-4 text-center text-gray-500">No hay fonemas cargados.</td></tr>`;
                return;
            }
            phonemes.forEach(entry => {
                const row = targetTableBody.insertRow();
                row.classList.add('hover:bg-gray-50', 'transition', 'duration-150');
                row.insertCell().textContent = entry.alias;
                row.insertCell().textContent = entry.wave_file_path;
            });
        }

        function updateSynthesisStatus(message) {
            synthesisStatusLabel.textContent = `Estado: ${message}`;
        }

        function updateCreatorStatus(message) {
            creatorStatusLabel.textContent = `Estado: ${message}`;
        }

        function updateSynthesisButtonsState() {
            const hasNotes = currentNotes.length > 0;
            saveHlButton.disabled = !hasNotes;
            playSynthesisButton.disabled = !hasNotes;
            saveSynthesisButton.disabled = !hasNotes; // Now enabled if notes exist
            editNoteButton.disabled = selectedNoteIndex === null;
            deleteNoteButton.disabled = selectedNoteIndex === null;
        }

        function populateLanguageCombo() {
            languageCombo.innerHTML = '';
            for (const name in languageOptions) {
                const option = document.createElement('option');
                option.value = languageOptions[name];
                option.textContent = name;
                languageCombo.appendChild(option);
            }
            languageCombo.value = 'es'; // Default to Spanish
        }

        function populateVoicebankCombo() {
            voicebankCombo.innerHTML = '<option value="">Seleccionar Voicebank...</option>';
            availableVoicebanks.forEach(vb => {
                const option = document.createElement('option');
                option.value = vb.id;
                option.textContent = `${vb.name} (${vb.author})`;
                voicebankCombo.appendChild(option);
            });
        }

        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });

            document.getElementById(`${tabId}-tab-content`).classList.remove('hidden');
            document.getElementById(`tab-${tabId}`).classList.add('active');
        }

        // --- Firebase Initialization & Listeners ---
        async function initializeFirebase() {
            showLoading();
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                    } else {
                        try {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                            } else {
                                await signInAnonymously(auth);
                            }
                            currentUserId = auth.currentUser.uid; // Get UID after sign-in
                        } catch (error) {
                            console.error("Error signing in:", error);
                            currentUserId = crypto.randomUUID(); // Fallback to a random ID
                            showModal("Error de Autenticaci√≥n", `No se pudo autenticar. Usando ID de usuario temporal. Error: ${error.message}`);
                        }
                    }
                    userIdDisplay.innerHTML = `ID de Usuario: <span class="font-mono bg-white bg-opacity-20 px-2 py-1 rounded-md">${currentUserId}</span>`;
                    isAuthReady = true;
                    hideLoading();
                    setupFirestoreListeners();
                });
            } catch (error) {
                hideLoading();
                console.error("Error initializing Firebase:", error);
                showModal("Error de Firebase", `No se pudo inicializar Firebase: ${error.message}`);
            }
        }

        function setupFirestoreListeners() {
            if (!db || !currentUserId || !isAuthReady) {
                console.warn("Firestore not ready for listeners.");
                return;
            }

            // HL Projects Listener
            const hlProjectsRef = doc(db, `artifacts/${appId}/users/${currentUserId}/hl_projects`, "my_project");
            onSnapshot(hlProjectsRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.notes && Array.isArray(data.notes)) {
                        currentNotes = data.notes.map(n => PianoNote.fromFirestore(n));
                        updatePianoRollTable();
                        updateSynthesisStatus(`Cargadas ${currentNotes.length} notas desde la nube.`);
                    }
                } else {
                    currentNotes = [];
                    updatePianoRollTable();
                    updateSynthesisStatus("No hay proyectos HL en la nube. Empieza uno nuevo.");
                }
            }, (error) => {
                console.error("Error fetching HL projects:", error);
                updateSynthesisStatus("Error al cargar proyectos HL desde la nube.");
            });

            // Voicebanks Listener
            const voicebanksCollectionRef = collection(db, `artifacts/${appId}/users/${currentUserId}/voicebanks`);
            onSnapshot(voicebanksCollectionRef, (snapshot) => {
                availableVoicebanks = [];
                snapshot.forEach((docSnap) => {
                    availableVoicebanks.push(Voicebank.fromFirestore(docSnap.id, docSnap.data()));
                });
                populateVoicebankCombo();
                updateSynthesisStatus(`Cargados ${availableVoicebanks.length} voicebanks desde la nube.`);
            }, (error) => {
                console.error("Error fetching voicebanks:", error);
                updateSynthesisStatus("Error al cargar voicebanks desde la nube.");
            });
        }

        // --- Event Handlers for Synthesis Tab ---
        async function handleLoadHLFile() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.hl';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                updateSynthesisStatus(`Cargando ${file.name}...`);
                showLoading();
                try {
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const fileContent = event.target.result;
                            const data = JSON.parse(fileContent);
                            if (data.notes && Array.isArray(data.notes)) {
                                currentNotes = data.notes.map(n => PianoNote.fromFirestore(n));
                                updatePianoRollTable();
                                // Save to Firestore
                                const docRef = doc(db, `artifacts/${appId}/users/${currentUserId}/hl_projects`, "my_project");
                                await setDoc(docRef, { notes: currentNotes.map(n => n.toFirestore()) });
                                updateSynthesisStatus(`Archivo HL '${file.name}' cargado y guardado en la nube.`);
                            } else {
                                throw new Error("Formato de archivo HL inv√°lido.");
                            }
                        } catch (parseError) {
                            showModal("Error al cargar HL", `Contenido HL inv√°lido o codificaci√≥n incorrecta: ${parseError.message}`);
                            updateSynthesisStatus("Error al cargar archivo HL.");
                        } finally {
                            hideLoading();
                        }
                    };
                    reader.readAsText(file);
                } catch (error) {
                    hideLoading();
                    showModal("Error al cargar HL", `Ocurri√≥ un error inesperado al cargar el archivo HL: ${error.message}`);
                    updateSynthesisStatus("Error al cargar archivo HL.");
                }
            };
            input.click();
        }

        async function handleSaveHLFile() {
            if (currentNotes.length === 0) {
                showModal("Guardar HL", "No hay notas para guardar.");
                return;
            }

            const currentNotesData = currentNotes.map(note => note.toFirestore());
            const dataToSave = { notes: currentNotesData };
            const jsonString = JSON.stringify(dataToSave, null, 4);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'my_song.hl';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Save to Firestore as well
            showLoading();
            try {
                const docRef = doc(db, `artifacts/${appId}/users/${currentUserId}/hl_projects`, "my_project");
                await setDoc(docRef, { notes: currentNotesData });
                updateSynthesisStatus("Archivo HL guardado localmente y en la nube.");
            } catch (error) {
                console.error("Error saving HL to Firestore:", error);
                showModal("Error de Guardado", `Error al guardar archivo HL en la nube: ${error.message}`);
                updateSynthesisStatus("Error al guardar archivo HL en la nube.");
            } finally {
                hideLoading();
            }
        }

        function handleAddNote() {
            const newStart = currentNotes.length > 0 ? currentNotes[currentNotes.length - 1].start + currentNotes[currentNotes.length - 1].length : 0;
            const newNote = new PianoNote(60, newStart, 100, "a");
            currentNotes.push(newNote);
            selectedNoteIndex = currentNotes.length - 1; // Select the newly added note
            updatePianoRollTable();
            updateSynthesisStatus("Nueva nota a√±adida.");
            // No need to save to Firestore immediately, user will save explicitly or it will be saved on next HL save.
        }

        function handleEditNote() {
            if (selectedNoteIndex === null || selectedNoteIndex >= currentNotes.length) {
                showModal("Editar Nota", "Por favor, selecciona una nota para editar.");
                return;
            }

            const noteToEdit = currentNotes[selectedNoteIndex];
            const content = `
                <div class="space-y-3">
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Tono (MIDI, 0-127):</label>
                        <input type="number" min="0" max="127" value="${noteToEdit.pitch}" id="edit-pitch" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50" />
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Inicio (ticks):</label>
                        <input type="number" min="0" value="${noteToEdit.start}" id="edit-start" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50" />
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Duraci√≥n (ticks):</label>
                        <input type="number" min="1" value="${noteToEdit.length}" id="edit-length" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50" />
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700">Letra:</label>
                        <input type="text" value="${noteToEdit.lyric}" id="edit-lyric" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-pink-300 focus:ring focus:ring-pink-200 focus:ring-opacity50" />
                    </div>
                </div>
            `;

            showModal("Editar Nota", content, true, async () => {
                noteToEdit.pitch = parseInt(document.getElementById('edit-pitch').value);
                noteToEdit.start = parseInt(document.getElementById('edit-start').value);
                noteToEdit.length = parseInt(document.getElementById('edit-length').value);
                noteToEdit.lyric = document.getElementById('edit-lyric').value;
                currentNotes[selectedNoteIndex] = noteToEdit; // Update the note in the array
                updatePianoRollTable();
                updateSynthesisStatus(`Nota en la fila ${selectedNoteIndex + 1} editada.`);

                // Save to Firestore
                showLoading();
                try {
                    const docRef = doc(db, `artifacts/${appId}/users/${currentUserId}/hl_projects`, "my_project");
                    await setDoc(docRef, { notes: currentNotes.map(n => n.toFirestore()) });
                } catch (error) {
                    console.error("Error saving updated HL to Firestore:", error);
                    showModal("Error de Guardado", `Error al guardar notas editadas en la nube: ${error.message}`);
                    updateSynthesisStatus("Error al guardar notas editadas en la nube.");
                } finally {
                    hideLoading();
                }
            });
        }

        async function handleDeleteNote() {
            if (selectedNoteIndex === null || selectedNoteIndex >= currentNotes.length) {
                showModal("Eliminar Nota", "Por favor, selecciona una nota para eliminar.");
                return;
            }

            showModal("Confirmar Eliminaci√≥n", "¬øEst√°s seguro de que quieres eliminar esta nota?", true, async () => {
                currentNotes.splice(selectedNoteIndex, 1); // Remove the note
                selectedNoteIndex = null; // Deselect
                updatePianoRollTable();
                updateSynthesisStatus("Nota eliminada.");

                // Save to Firestore
                showLoading();
                try {
                    const docRef = doc(db, `artifacts/${appId}/users/${currentUserId}/hl_projects`, "my_project");
                    await setDoc(docRef, { notes: currentNotes.map(n => n.toFirestore()) });
                } catch (error) {
                    console.error("Error deleting HL to Firestore:", error);
                    showModal("Error de Eliminaci√≥n", `Error al eliminar nota en la nube: ${error.message}`);
                    updateSynthesisStatus("Error al eliminar nota en la nube.");
                } finally {
                    hideLoading();
                }
            });
        }

        function handlePlaySynthesis() {
            if (currentNotes.length === 0) {
                showModal("Audio", "No hay notas para reproducir.");
                return;
            }

            updateSynthesisStatus("Sintetizando y reproduciendo audio...");
            showModal(
                "Nota Importante: Tono del Voicebank",
                "La funci√≥n 'Reproducir Audio' utiliza la API de Web Speech del navegador. Esto significa que **NO puede aplicar el tono, timbre o caracter√≠sticas espec√≠ficas de un voicebank personalizado** (como los que se crean en la pesta√±a 'Crear Voicebank HLVB'). Utilizar√° las voces predeterminadas de tu sistema operativo. Para una s√≠ntesis con voicebanks personalizados, se requerir√≠a un modelo de IA de s√≠ntesis de voz ejecut√°ndose en el navegador (muy complejo) o un servidor backend dedicado."
            );

            const textToSpeak = currentNotes.map(note => note.lyric).join(" ");
            const utterance = new SpeechSynthesisUtterance(textToSpeak);
            utterance.lang = languageCombo.value;

            utterance.onend = () => {
                updateSynthesisStatus("Reproducci√≥n finalizada.");
            };
            utterance.onerror = (event) => {
                updateSynthesisStatus(`Error de s√≠ntesis: ${event.error}`);
                console.error("SpeechSynthesisUtterance error:", event);
            };

            window.speechSynthesis.speak(utterance);
        }

        async function handleSaveSynthesis() {
            if (currentNotes.length === 0) {
                showModal("Audio", "No hay notas para sintetizar y guardar.");
                return;
            }

            updateSynthesisStatus("Sintetizando audio para guardar...");
            showLoading();

            showModal(
                "Aviso: Tono del Voicebank en WAV",
                "El archivo WAV que se generar√° contendr√° la s√≠ntesis de voz de la API de Web Speech de tu navegador. Esto significa que **NO aplicar√° el tono, timbre o caracter√≠sticas espec√≠ficas de un voicebank personalizado**. Para obtener un WAV con el tono real de un voicebank, se necesitar√≠a un motor de s√≠ntesis de voz de IA en un servidor backend."
            );

            const textToSynthesize = currentNotes.map(note => note.lyric).join(" ");
            const lang = languageCombo.value;

            // Use a promise to wait for speech synthesis to complete
            const synthesizeSpeech = (text, language) => {
                return new Promise((resolve, reject) => {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = language;

                    // This part is the tricky bit: connecting SpeechSynthesis to AudioContext.
                    // Directly connecting SpeechSynthesisUtterance to an AudioContext is not possible.
                    // For demonstration, we'll simulate a WAV from the text.

                    // To generate a WAV, we'd need raw audio data.
                    // For simplicity and demonstrating the WAV download, we'll create a dummy WAV.
                    // A real implementation would involve a server-side TTS engine or a complex
                    // client-side WASM model.

                    // For now, let's create a *dummy* WAV file based on the text length.
                    // This is NOT capturing the actual browser TTS output, but demonstrating the save mechanism.
                    const dummyAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const sampleRate = 44100; // Standard sample rate
                    const duration = text.length * 0.1; // Estimate duration based on text length
                    const frameCount = sampleRate * duration;
                    const myArrayBuffer = dummyAudioContext.createBuffer(1, frameCount, sampleRate);
                    const nowBuffering = myArrayBuffer.getChannelData(0);

                    // Fill with some dummy data (e.g., silence or a simple tone)
                    for (let i = 0; i < frameCount; i++) {
                        nowBuffering[i] = Math.sin(i * 0.05); // Simple sine wave for demonstration
                    }

                    // Encode to WAV
                    const worker = new Worker(URL.createObjectURL(new Blob([`
                        self.onmessage = function(e) {
                            const data = e.data.audioData;
                            const sampleRate = e.data.sampleRate;
                            const numChannels = 1; // Mono
                            const bytesPerSample = 2; // 16-bit PCM

                            function writeString(view, offset, string) {
                                for (let i = 0; i < string.length; i++) {
                                    view.setUint8(offset + i, string.charCodeAt(i));
                                }
                            }

                            function floatTo16BitPCM(output, offset, input) {
                                for (let i = 0; i < input.length; i++, offset += 2) {
                                    const s = Math.max(-1, Math.min(1, input[i]));
                                    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                                }
                            }

                            const dataLength = data.length * bytesPerSample;
                            const buffer = new ArrayBuffer(44 + dataLength);
                            const view = new DataView(buffer);

                            writeString(view, 0, 'RIFF');
                            view.setUint32(4, 36 + dataLength, true);
                            writeString(view, 8, 'WAVE');
                            writeString(view, 12, 'fmt ');
                            view.setUint32(16, 16, true);
                            view.setUint16(20, 1, true); // PCM
                            view.setUint16(22, numChannels, true);
                            view.setUint32(24, sampleRate, true);
                            view.setUint32(28, sampleRate * numChannels * bytesPerSample, true);
                            view.setUint16(32, numChannels * bytesPerSample, true);
                            view.setUint16(34, bytesPerSample * 8, true); // Bits per sample
                            writeString(view, 36, 'data');
                            view.setUint32(40, dataLength, true);

                            floatTo16BitPCM(view, 44, data);

                            self.postMessage(buffer, [buffer]);
                        };
                    `]), { type: 'application/javascript' }));

                    worker.onmessage = event => {
                        const wavBlob = new Blob([event.data], { type: 'audio/wav' });
                        resolve(wavBlob);
                    };

                    worker.onerror = error => {
                        reject("Error in WAV encoding worker: " + error.message);
                    };

                    worker.postMessage({
                        audioData: nowBuffering,
                        sampleRate: sampleRate
                    });
                });
            };

            try {
                const audioBlob = await synthesizeSpeech(textToSynthesize, lang);
                const url = URL.createObjectURL(audioBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'synthesized_audio.wav';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                updateSynthesisStatus("Audio WAV guardado exitosamente.");
            } catch (error) {
                showModal("Error al guardar Audio", `No se pudo guardar el archivo de audio: ${error}`);
                updateSynthesisStatus("Error al guardar audio.");
            } finally {
                hideLoading();
            }
        }

        function handleVoicebankSelection() {
            const selectedId = voicebankCombo.value;
            if (selectedId === "") {
                selectedVoicebank = null;
                updateSynthesisStatus("Voicebank no seleccionado.");
                selectedVoicebankInfo.innerHTML = '';
                updatePhonemeTable({}, phonemeTableBody);
                return;
            }
            const vb = availableVoicebanks.find(vb => vb.id === selectedId);
            selectedVoicebank = vb;
            if (vb) {
                updateSynthesisStatus(`Voicebank '${vb.name}' cargado.`);
                selectedVoicebankInfo.innerHTML = `
                    <p><strong>Nombre:</strong> ${vb.name}</p>
                    <p><strong>Autor:</strong> ${vb.author}</p>
                    <p><strong>Descripci√≥n:</strong> ${vb.description}</p>
                `;
                updatePhonemeTable(vb.phoneme_map, phonemeTableBody);
            } else {
                updateSynthesisStatus("Error: Voicebank no encontrado.");
                selectedVoicebankInfo.innerHTML = '';
                updatePhonemeTable({}, phonemeTableBody);
            }
        }

        // --- Event Handlers for Vocaloid Changer ---
        async function handleVocaloidifyText() {
            const inputText = inputVocaloidText.value.trim();
            if (!inputText) {
                showModal("Vocaloid Changer", "Por favor, introduce texto para vocaloid-ificar.");
                return;
            }

            updateSynthesisStatus("Vocaloid-ificando texto...");
            showLoading();
            outputVocaloidText.value = "Procesando...";

            try {
                const prompt = `Transform the following text into a style reminiscent of a Vocaloid singing voice. Focus on slightly exaggerated pronunciation, clear but somewhat robotic articulation, and a slightly simplified phonetic feel. Do not add any musical notation or timing, just modify the words themselves. Example: 'Hello world' could become 'Ha-lo wor-ul-do'. Text: ${inputText}`;

                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const transformedText = result.candidates[0].content.parts[0].text;
                    outputVocaloidText.value = transformedText;
                    updateSynthesisStatus("Texto vocaloid-ificado.");
                } else {
                    outputVocaloidText.value = "Error al vocaloid-ificar.";
                    showModal("Error Vocaloid Changer", "No se pudo obtener una respuesta del modelo. Int√©ntalo de nuevo.");
                    updateSynthesisStatus("Error al vocaloid-ificar texto.");
                }
            } catch (error) {
                outputVocaloidText.value = "Error.";
                showModal("Error Vocaloid Changer", `Ocurri√≥ un error al comunicarse con el LLM: ${error.message}`);
                updateSynthesisStatus("Error al vocaloid-ificar texto.");
                console.error("LLM Vocaloid Changer error:", error);
            } finally {
                hideLoading();
            }
        }

        function handlePlayVocaloidText() {
            const textToPlay = outputVocaloidText.value.trim();
            if (!textToPlay) {
                showModal("Vocaloid Changer", "No hay texto vocaloid-ificado para reproducir.");
                return;
            }

            updateSynthesisStatus("Reproduciendo texto vocaloid-ificado...");
            showModal(
                "Nota Importante: Reproducci√≥n Vocaloid",
                "Est√°s escuchando el texto transformado por el 'Vocaloid Changer' (simulado). La reproducci√≥n de audio utiliza la API de Web Speech de tu navegador y **NO aplica el tono o timbre de un voicebank personalizado**. Para una s√≠ntesis Vocaloid real, se necesita un motor de IA de s√≠ntesis de voz dedicado."
            );

            const utterance = new SpeechSynthesisUtterance(textToPlay);
            utterance.lang = languageCombo.value; // Use selected language for playback

            utterance.onend = () => {
                updateSynthesisStatus("Reproducci√≥n de texto vocaloid-ificado finalizada.");
            };
            utterance.onerror = (event) => {
                updateSynthesisStatus(`Error de reproducci√≥n: ${event.error}`);
                console.error("SpeechSynthesisUtterance error (Vocaloid Changer):", event);
            };

            window.speechSynthesis.speak(utterance);
        }

        // --- Event Handlers for Creator Tab ---
        function handleOtoIniUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            updateCreatorStatus("Cargando oto.ini...");
            showLoading();
            const reader = new FileReader();
            reader.onload = (event) => {
                currentOtoIniContent = event.target.result;
                try {
                    const dummyVoicebank = new Voicebank('dummy', '', '', '', currentOtoIniContent);
                    updatePhonemeTable(dummyVoicebank.phoneme_map, creatorPhonemeTableBody);
                    otoIniContentDisplay.textContent = currentOtoIniContent.substring(0, 500) + (currentOtoIniContent.length > 500 ? '...' : '');
                    otoIniPreviewDiv.classList.remove('hidden');
                    updateCreatorStatus(`OTO.ini cargado con ${Object.keys(dummyVoicebank.phoneme_map).length} fonemas.`);
                } catch (error) {
                    updateCreatorStatus("Error al analizar oto.ini. Aseg√∫rate de que el formato sea correcto.");
                    otoIniPreviewDiv.classList.add('hidden');
                    updatePhonemeTable({}, creatorPhonemeTableBody);
                    console.error("Error parsing oto.ini:", error);
                } finally {
                    hideLoading();
                }
            };
            reader.readAsText(file);
        }

        async function handleTrainAndPack() {
            const name = vbNameInput.value.trim();
            const author = vbAuthorInput.value.trim();
            const description = vbDescInput.value.trim();
            const epochs = parseInt(vbEpochsInput.value);

            if (!name || !author || !currentOtoIniContent) {
                showModal("Error", "Por favor, completa el nombre, autor y carga un archivo oto.ini.");
                return;
            }
            if (isNaN(epochs) || epochs <= 0) {
                showModal("Error de √âpocas", "Por favor, introduce un n√∫mero v√°lido de √©pocas (entero positivo).");
                return;
            }

            updateCreatorStatus("Iniciando entrenamiento y empaquetado (simulado)...");
            showLoading();

            // Simulate training delay
            await new Promise(resolve => setTimeout(resolve, 3000));

            try {
                const infoJsonContent = JSON.stringify({ name, author, description, hlvb_version: "1.0" }, null, 2);
                const newVoicebankData = {
                    name,
                    author,
                    description,
                    otoIniContent: currentOtoIniContent,
                    infoJsonContent: infoJsonContent,
                    hlvb_version: "1.0",
                };

                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${currentUserId}/voicebanks`), newVoicebankData);

                updateCreatorStatus(`¬°Voicebank HLVB creado con √©xito! ID: ${docRef.id}. (Simulado)`);
                showModal("√âxito", `Voicebank '${name}' creado y guardado en la nube.`);
            } catch (error) {
                console.error("Error during simulated training/packing:", error);
                updateCreatorStatus(`Error durante el entrenamiento/empaquetado: ${error.message}`);
                showModal("Error", `Error durante el entrenamiento/empaquetado: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // --- Initial Setup ---
        document.addEventListener('DOMContentLoaded', () => {
            initializeFirebase();
            populateLanguageCombo();
            updatePianoRollTable(); // Initial render of empty table
            updatePhonemeTable({}, phonemeTableBody); // Initial render of empty phoneme table
            updatePhonemeTable({}, creatorPhonemeTableBody); // Initial render for creator tab
            updateSynthesisButtonsState(); // Set initial button states

            // Tab switching
            synthesisTabBtn.addEventListener('click', () => showTab('synthesis'));
            creatorTabBtn.addEventListener('click', () => showTab('creator'));

            // Synthesis Tab Event Listeners
            loadHlButton.addEventListener('click', handleLoadHLFile);
            saveHlButton.addEventListener('click', handleSaveHLFile);
            addNoteButton.addEventListener('click', handleAddNote);
            editNoteButton.addEventListener('click', handleEditNote);
            deleteNoteButton.addEventListener('click', handleDeleteNote);
            playSynthesisButton.addEventListener('click', handlePlaySynthesis);
            saveSynthesisButton.addEventListener('click', handleSaveSynthesis);
            voicebankCombo.addEventListener('change', handleVoicebankSelection);

            // Vocaloid Changer Event Listeners
            vocaloidifyButton.addEventListener('click', handleVocaloidifyText);
            playVocaloidTextButton.addEventListener('click', handlePlayVocaloidText);

            // Creator Tab Event Listeners
            otoIniUploadInput.addEventListener('change', handleOtoIniUpload);
            trainPackButton.addEventListener('click', handleTrainAndPack);
        });
    </script>
</body>
</html>
